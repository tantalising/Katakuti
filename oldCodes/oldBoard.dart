
// class Board extends StatelessWidget {
//   final width;
//   final height;
//
//   const Board({Key key, @required this.width, @required this.height})
//       : super(key: key);
//
//   @override
//   Widget build(BuildContext context) {
//     var tablePosition = [1, 2, 3]; // This is actually used as a iterable for
//     // generating the table like this:
//     // for row in tablePosition: for column in tablePosition: render the cells
//
//     return Container(
//       alignment: Alignment.center,
//       width: width,
//       height: height,
//       child: Table(
//         children: tablePosition
//             .map(
//               (row) => TableRow(
//                   children: tablePosition
//                       .map((column) => Cell(
//                             color:
//                                 getColor((row - 1) * 3 + (column - 1), context),
//                             width: width,
//                             height: height,
//                             cellId: (row - 1) * 3 + (column - 1),
//                             disable: shouldDisable(row,
//                                 column), // decide which borders of the cells are to be disabled, if any.
//                           ))
//                       .toList()),
//             )
//             .toList(),
//       ),
//     );
//   }
//
//   // This function decides which borders of the cell to be disabled
//   shouldDisable(int row, int column) {
//     row -= 1; // For mapping the 2d point to one dimension we need to
//     column -= 1; // have the origin at (0,0) instead of currently used (1,1)
//
//     var position = row * 3 + column;
//
//     var borderList = [
//       "topLeft",
//       "top",
//       "topRight",
//       "left",
//       "center", // It has no use now
//       "right",
//       "bottomLeft",
//       "bottom",
//       "bottomRight",
//     ];
//
//     return borderList[position];
//   }
//
//   // Color for the cell. If the game is over and there is  a winner and the cell contains a piece of that winner then change its color.
//   // If there is no winner then change color of all the cells.
//   getColor(id, context) {
//     if (gameInfo.gameOver) {
//       if (gameInfo.winnerPiecePositionList[0] != 10) {
//         if (gameInfo.winnerPiecePositionList[0] == id ||
//             gameInfo.winnerPiecePositionList[1] == id ||
//             gameInfo.winnerPiecePositionList[2] == id)
//           return Theme.of(context).errorColor.withOpacity(0.1);
//       } else
//         return Theme.of(context).errorColor.withOpacity(0.1);
//     }
//     return null;
//   }
// }
//
// // Cell of the table of size 3x3
// class Cell extends StatelessWidget {
//   final width;
//   final height;
//   final disable; // the border side to be disabled
//   final color;
//   final cellId;
//
//   const Cell(
//       {Key key,
//       this.width,
//       this.height,
//       this.disable,
//       @required this.cellId, // Cell number generated by aforementioned mapping
//       this.color})
//       : super(key: key);
//
//   @override
//   Widget build(BuildContext context) {
//     var bottomColor = Theme.of(context).primaryColor.withOpacity(0.6);
//     var topColor = Theme.of(context).primaryColor.withOpacity(0.6);
//     var leftColor = Theme.of(context).primaryColor.withOpacity(0.6);
//     var rightColor = Theme.of(context).primaryColor.withOpacity(0.6);
//
//     // Disable the necessary borders for making a tic-tac-toe game grid
//     switch (disable) {
//       case "top":
//         topColor = Colors.transparent;
//         break;
//       case "bottom":
//         bottomColor = Colors.transparent;
//         break;
//       case "left":
//         leftColor = Colors.transparent;
//         break;
//       case "right":
//         rightColor = Colors.transparent;
//         break;
//       case "topLeft":
//         topColor = Colors.transparent;
//         leftColor = Colors.transparent;
//         break;
//       case "topRight":
//         topColor = Colors.transparent;
//         rightColor = Colors.transparent;
//         break;
//       case "bottomLeft":
//         bottomColor = Colors.transparent;
//         leftColor = Colors.transparent;
//         break;
//       case "bottomRight":
//         bottomColor = Colors.transparent;
//         rightColor = Colors.transparent;
//         break;
//     }
//
//     // Return the made cell
//     return Container(
//       width: width / 3,
//       height: height / 3,
//       decoration: BoxDecoration(
//         color: color,
//         border: Border(
//           bottom: BorderSide(color: bottomColor),
//           top: BorderSide(color: topColor),
//           left: BorderSide(color: leftColor),
//           right: BorderSide(color: rightColor),
//         ),
//       ),
//
//       // The piece of our game. it will change it's piece and onPressed color when needed
//       child: Guti(
//         cellId: cellId,
//       ),
//     );
//   }
// }